#!/usr/bin/env minivx -Z

let bindir = dirname realpath argv[ 0 ]
let libdir = bindir "/../lib/"

def import (lib) { eval (load, realpath) libdir lib ".vy" }

let basename = import "basename";

let info_plist = import "info_plist"
let render_xml = import "render_xml"

def comma-separated (prev, next)
{
	let c = prev[ prev.length - 1 ]
	
	return prev ("," * not c in ":[" ) "\n" next
}

def exists (path)
{
	return try {stat path; true} catch {false}
}

def mkdir-p
{
	run [ "mkdir", "-p", _ ]
}

def copy
{
	run [ "cp", "-fpR", _ ]
}

def vx_Z (script_filename) { "minivx", "-Z", bindir "/" script_filename }

def choose_frontend
{
	let is_arm64 = output-from-run [ "arch" ] == "arm64\n"
	let frontend = if is_arm64 then {"Amethyst"} else {"Amphitheatre"}
	
	if let retro_frontend = getenv "RETRO_FRONTEND" then
	{
		if retro_frontend != frontend then
		{
			warn "retromatic: "
			     "Using " retro_frontend " as front end "
			     "instead of default " frontend
		}
		
		return retro_frontend
	}
	
	return frontend
}

let frontend = choose_frontend()

let output_dir = argv[ 1 ]
let input_path = argv[ 2 ]

if not exists input_path then
{
	warn "retromatic.vx: " input_path ": No such file or directory"
	
	exit 1
}

let parent_dir = dirname input_path

let src_is_txt = -substr( -input_path, 0, 4 ) == ".txt"

let config_data = if src_is_txt then {load input_path} else {""}

let config_lines = config_data.lines() ver bool per comma-separated or "()"

let config = str^[eval( config_lines, realpath input_path )]

def active (feature)
{
	return feature in config and config[ feature ]
}

let named = "name" in config

if src_is_txt and not named then
{
	warn "retromatic.vx: " input_path ": Required field 'name' is missing"
	
	exit 1
}

var name = if src_is_txt then {config[ "name" ]} else {basename input_path}

# This path may not actually exist in the case of a disk image.
# Really it's just the fs root path and the app name joined by "/".

var name_path = parent_dir "/" name

var new_disk = ""

const disk

if "disk" in config then
{
	disk = config[ "disk" ]
}
else if src_is_txt and not exists name_path and exists name_path ".mbin" then
{
	disk = name ".mbin"
	
	new_disk = ("disk: " rep disk) "\n"
}
else if -substr( -name, 0, 5 ) == ".mbin" then
{
	disk = name
	name = (output-from-run [ "var/out/mbin", "name", input_path ]).lines()[ 0 ]
	
	name_path = parent_dir "/" name
	
	new_disk = ("disk: " rep disk) "\n"
}
else
{
	disk = null
}

const name_to_copy

if disk then
{
	name_to_copy = disk
	
	setenv( "AMS_DISK", name_to_copy )
}
else
{
	name_to_copy = name
}

let new_app_dir = output_dir "/" name ".app"
let contents = new_app_dir "/Contents"

let MacOS_dir = contents "/MacOS"
let Resources = contents "/Resources"
let xv68k_dir = contents "/xv68k"

let Files = Resources "/Files"

mkdir-p (MacOS_dir, Files "/AMS Resources", xv68k_dir)

def ams-get-app (property, args: ...)
{
	let path = name_path
	
	return packed output-from-run [ vx_Z "ams-get.vx", property, path, args ]
}

def icns (icon)
{
	assert icon.size == 256
	
	return packed ('icns', x"00000110", 'ICN#', x"00000108", icon)
}

let creator = mb32 ams-get-app "bndl-owner"
let icon    = icns ams-get-app ("bndl-icon", "APPL")

rewrite Resources "/" name ".icns" <== icon

let resfiles = [ "AMS Resources", "System" ]
let respaths = resfiles map { parent_dir "/" v } ver { exists v "/r" }

run [ vx_Z "mkrsrc.vx", "-o", Files "/AMS Resources/rsrc", *respaths ]

copy( parent_dir "/" name_to_copy, Files )

if "files" in config then
{
	let files = config[ "files" ] map { parent_dir "/" v }
	
	copy( *files, Files )
}

let ams_bin = "../ams-68k-bin/bin"
let ams_lib = "../ams-68k-bin/lib"

let prefix_list = "core io fs snd rsrc pack seg qd ui print"
let ams_modules = [ prefix_list / ' ' ] map {ams_lib "/ams-" v}

copy( *ams_modules, ams_lib "/umsp", ams_bin "/app", xv68k_dir )

let new_data = ("name: " rep name) "\n" * not named

rewrite Resources "/config.txt" <== new_data new_disk config_data

let tools = "mac/libs/amicus/tools/launch-ams-app.vx"

let native_binary_names = ["minivx graft xv68k freemountd" / ' ']
let native_binary_paths = native_binary_names map {"var/out/" v}

copy( tools, *native_binary_paths, MacOS_dir )

if active "sound" and exists "var/out/sndtrack" then
{
	copy( "var/out/sndtrack", MacOS_dir )
}

if frontend != "Amber" and exists "var/out/Amber" then
{
	copy( "var/out/Amber", MacOS_dir )
}

copy( "var/out/" frontend, MacOS_dir )

var plist_xml_lines = [ info_plist.version, info_plist.doctype ]

def document_icons_table
{
	let table = try { config[ "document-icons" ] } catch { [] }
	
	return mb32^(table map { mb32 v.key => v.value })
}

let doctypes =
if "document-types" in config then
{
	let document-types = config[ "document-types" ]
	let document-icons = document_icons_table()
	
	let doctypes = document-types map
	{
		let name = translated( str v.key, "/\0", ": " );
		
		let type_key = mb32 v.key
		
		let icon_key = if type_key in document-icons
			then { document-icons[ type_key ] }
			else {                 type_key   }
		
		let icon = icns ams-get-app ("bndl-icon", str icon_key)
		
		[
			CFBundleTypeName: v.value,
			CFBundleTypeOSTypes: [ v.key ],
			
			if icon.size then
			{
				rewrite Resources "/" name ".icns" <== icon
				
				CFBundleTypeIconFile: name,
			},
		],
	}
	
	CFBundleDocumentTypes: doctypes,
}

let info =
[
	CFBundleExecutable:  frontend,
	CFBundleIconFile:    name,
	CFBundleName:        name,
	CFBundlePackageType: 'APPL',
	CFBundleSignature:   creator,
	CFBundleVersion:     "for Advanced Mac Substitute",
	CFBundleGetInfoString: "(using the " frontend " front end)",
	NSHighResolutionCapable: true,
	
	doctypes,
]

def printer (depth, text)
{
	let Tab = "\t"
	
	let tabs = Tab * depth
	
	plist_xml_lines <-- tabs text
}

render_xml( printer, info_plist.convert info )

let plist = "\n".join( *plist_xml_lines, "" )

rewrite contents "/Info.plist" <== plist

run [ bindir "/fndr-sync.vx", new_app_dir ]
