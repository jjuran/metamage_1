#!/usr/bin/env minivx -Z

assert argv[ 1 ] == "-o"

let output_file = argv[ 2 ]
let input_files = argv[ 3 -> argc ]

var types = mb32^[]

let encode_u16BE = (big-endian u16).encode
let encode_u32BE = (big-endian u32).encode

def add_rsrc (data, name)
{
	if name.length != 9 or name[ 0 ] == '.' then
	{
		return ()
	}
	
	let resid = i16 unhex "0x" name[ 0 -> 4 ]
	let rtype = mb32           name[ 5 -> 9 ]
	
	if not rtype in types then
	{
		types[ rtype ] = i16^[]
	}
	
	types[ rtype ][ resid ] = data
}

for resfile in input_files do
{
	let dir = resfile "/r/"
	
	let rsrcs = listdir dir
	
	for rsrc in rsrcs do
	{
		let path = dir rsrc
		
		add_rsrc (packed load path, rsrc)
	}
}

let rsrc_count = types.values map {v.length} per Math.sum

let typelist_size = 2 + 8 * types.length

var type_list = encode_u16BE (types.length - 1)

var rsrc_headers = x""
var data_section = x""

for type_rsrcs in types do
{
	let rtype = type_rsrcs.key
	let rsrcs = type_rsrcs.value
	
	let offset = encode_u16BE (typelist_size + rsrc_headers.size)
	
	type_list = type_list (packed rtype) encode_u16BE( rsrcs.length - 1 ) offset
	
	for id_rsrc in rsrcs do
	{
		let id   = id_rsrc.key
		let rsrc = id_rsrc.value
		
		let offset = encode_u32BE data_section.size
		
		rsrc_headers = rsrc_headers (encode_u16BE id) x"ffff" offset x"00000000"
		data_section = data_section (encode_u32BE rsrc.size) rsrc
	}
}

let rsrc_map_size = 28 + typelist_size + rsrc_headers.size

let map_offset = 256 + data_section.size

let header_fields = [256, map_offset, data_section.size, rsrc_map_size ]

let offsets = x"001c" encode_u16BE (0x1c + typelist_size + rsrc_headers.size)

let rsrc_fork_header = header_fields map encode_u32BE per packed
let rsrc_map_header  = rsrc_fork_header (x"00" * 8) offsets

let rsrc_map = rsrc_map_header type_list rsrc_headers

var out = rewrite output_file

out <== rsrc_fork_header, x"00" * (112 + 128), data_section, rsrc_map
